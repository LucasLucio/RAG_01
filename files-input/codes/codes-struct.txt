
;Criação e  atribuição de dados em struct
entry plConsultaCredenciais
	params
		struct pStcCredencial : OUT
	endparams

	;Inicializa uma struct para armazenar resultado de saida
	pStcCredencial = $newstruct

	;Realiza condicional if, para avaliar o ambiente na constante do nome database e retornar o valor
	if (<NOME_DATABASE> = "PRODUCAO")
		pStcCredencial->ci = "dce3e984-c73a-4f02-a256-400675e292e4"
		pStcCredencial->cs = "CS-EXEMPLO"
	elseif (<NOME_DATABASE> = "TREINAMENTO") 
		pStcCredencial->ci = "dce3e984-c73a-4f02-a256-400675e292e4"
		pStcCredencial->cs = "CS-EXEMPLO"
	elseif (<NOME_DATABASE> = "DESENVOLVIMENTO")
		pStcCredencial->ci = "dce3e984-c73a-4f02-a256-400675e292e4"
		pStcCredencial->cs = "CS-EXEMPLO"
	endif

	return (0)
end


;Utilização de struct como parâmetros 
operation enviaEmail
	params
		Struct pStcInput			: IN
		Struct pStcOutput			: OUT
		Struct pStcOutputError	    : OUT
	endParams
	variables
		String	vStrContextoErro
		Struct	vStcTemp
	endVariables

	;Configurações iniciais para tratamentos de erro
	vStrContextoErro	= "(%%$componentname%%%.enviaEmail)"
	vStcTemp				= ""
	pStcOutput			= ""
	pStcOutputError	= ""

	;Criação de uma struct
	vStcTemp->"%%(pStcInput->versao)%%%"	= $newStruct
	vStcTemp->"%%(pStcInput->versao)%%%"->*{-1}	= pStcInput->*
	vStcTemp->"%%(pStcInput->versao)%%%"->*{-1}	= pStcInput->payload->*
	vStcTemp->"%%(pStcInput->versao)%%%"->payload->$parent	= ""
	;Chamada de uma função local do componente
	call plValidaParametros(vStcTemp,pStcOutputError)
	;Tratamento de erros
	if ($status < 0)
		if ($status = <g_erroexec>)
			call plErroWeb("", "", "", vStrContextoErro, pStcOutputError)
		else
			call pl_erro_cmdmsg($procerrorcontext)
			call plErroWeb(500, $t_ds_erro$, "", vStrContextoErro, pStcOutputError)
		endif
		return(<g_erroexec>)
	endif

	;Reinicialização de uma variável struct
	vStcTemp	= ""

	;Switch/case para verificação de versão 
	selectCase pStcInput->versao 
		case	"v1" ;Vericficação do case da variável

			;Chamada de operação a ser executada
			call plEnviaEmail_v1 (pStcInPut,pStcOutput,pStcOutputError)
			;Tratamento de erros
			if ($status < 0)
				if ($status = <g_erroexec>)
					call plErroWeb("", "", "", vStrContextoErro, pStcOutputError)
				else
					call pl_erro_cmdmsg($procerrorcontext)
					call plErroWeb(500, $t_ds_erro$, "", vStrContextoErro, pStcOutputError)
				endif
				return(<g_erroexec>)
			endif

		elseCase ; Caso else do switch/case
			call plErroWeb(500, "Versão(versao) é um parâmetro obrigatório.", "", vStrContextoErro, pStcOutputError)
			return(<g_erroexec>)
	endSelectCase

	;Limpeza de variáveis para finalização
	vStrContextoErro	= ""
	vStcTemp				= ""
	pStcOutputError	= ""

	return(0) ;Retorno da operation com sucesso

end ;enviaEmail


;Montagem e atribuição de dados em Struct
entry plReservaMotivosRecusa
	params ;Parâmetros de entrada e saída 
		;Tipo parâmetro - NomeParâmetro - Definição de entrada ou saída
		struct pStcInput   : IN
		struct pStcOutput  : OUT
		struct pStcErro    : OUT
		$t_ds_erro$        : OUT
	endparams
	variables
		struct vStcTemp, vStcToken
		string vStrUrlTemp, vStrHeader, vStrContextoErro, vStrResult, vStrJsonInput
	endvariables

	;Inicialização de estrutura para tratamento de erros
	vStrContextoErro	= "(%%$componentname%%%.plReservaMotivosRecusa)"
	vStcTemp			= ""
	$t_ds_erro$			= ""

	;Preparação de variáveis da execução
	vStcTemp->requestMethod	= "GET"

	call plUrlAmbiente(vStrUrlTemp)
	vStcTemp->url = $concat(vStrUrlTemp, "/reserva/motivos-recusa")

	vStcTemp->timeout = 60

	vStcTemp->headerDelimitator	= "@"
	vStrHeader = $concat("Content-Type: ", "application/json")

	activate "LFREO007".opAuth(vStcToken)
	if ($status < 0) ;Uso de condicional para tratamento do erro da chamada executada acima
		if ($status != <g_erroexec>)
			call pl_erro_cmdmsg($procerrorcontext)
		else
			$t_ds_erro$ = "%%$t_ds_erro$%%% %%vStrContextoErro%%%"
		endIf
		return(<g_erroexec>)
	endIf
	
	vStrHeader = $concat(vStrHeader, "@", "Authorization: ", "Bearer ", vStcToken->access_token)

	vStcTemp->header = vStrHeader

	structToJson vStrJsonInput, pStcInput

	vStcTemp->payload = vStrJsonInput

	vStcTemp->componentUniface 	= $componentname

	;Chamada de API externa
	activate "WSGEW003".consomeRest(	vStcTemp->requestMethod,		    %\
										vStcTemp->url,						%\
										vStcTemp->headerDelimitator,	    %\
										vStcTemp->header,					%\
										vStcTemp->timeout,				    %\
										"true",								%\
										vStcTemp->componentUniface,	        %\
										"",									%\
										vStcTemp->payload	,				%\
										vStcTemp->inicio,					%\
										vStcTemp->fim,						%\
										vStcTemp->responseCode,		        %\
										vStcTemp->headerResponse,		    %\
										vStcTemp->restResponse               )
	if ($status < 0) ;Uso de condicional para tratamento do erro da chamada executada acima
		if ($status != <g_erroexec>)
			call pl_erro_cmdmsg($procerrorcontext)
		else
			$t_ds_erro$ = "%%$t_ds_erro$%%% %%vStrContextoErro%%%"
		endIf
		return(<g_erroexec>)
	endIf

	if ($number(vStcTemp->responseCode) >= 300)  ;Uso de condicional para tratamento do retorno de requisição
		pStcErro = ""
		call plTrataErroRequest(vStrContextoErro,vStcTemp->restResponse,pStcErro)

		$t_ds_erro$	= pStcErro->mensagem
		$t_ds_erro$	= "%%$t_ds_erro$%%% %%vStrContextoErro%%%"
		return(<g_erroexec>)
	endIf

	;Conversão dos dados
	vStrResult	= vStcTemp->restResponse
	jsonToStruct pStcOutput, vStrResult

end

;Obtenção de dados de uma struct
entry plDefinirTipoClassifica
	params ;Parâmetros de entrada e saída 
		;Tipo parâmetro - NomeParâmetro - Definição de entrada ou saída
		struct p_stc_veiculo 		:IN
		struct p_stc_hitCompveic	:INOUT
		numeric p_nr_ordem 			:IN
	endparams
	variables ;Definição de variáveis
		string v_ds_contexto, v_nr_placa_reboque01, v_nr_placa_reboque02, v_nr_placa_dolly
		numeric v_nr_ordem
	endvariables

	;Preparação para retorno de erros
	v_ds_contexto = "%%^%%%(<$componentname>, pl_definir_tp_classifica)"

	;Atribuição dos valores de struc para variáveis
	v_nr_placa_reboque01 = p_stc_hitCompveic->OCC{2}->NR_PLACA
	v_nr_placa_reboque02 = p_stc_hitCompveic->OCC{3}->NR_PLACA
	v_nr_placa_dolly     = p_stc_hitCompveic->OCC{4}->NR_PLACA

	;Abertura selectcase
	selectcase p_nr_ordem
		case 1
			p_stc_hitCompveic->OCC{p_nr_ordem}->TP_CLASSIFICA  =  3
			if (v_nr_placa_reboque01 != "" | v_nr_placa_reboque02 != "" | v_nr_placa_dolly != "")
				p_stc_hitCompveic->OCC{p_nr_ordem}->TP_CLASSIFICA  =  6
			endif
		case 4  
			p_stc_hitCompveic->OCC{p_nr_ordem}->TP_CLASSIFICA  = 14
		case 2, 3 
			p_stc_hitCompveic->OCC{p_nr_ordem}->TP_CLASSIFICA  = 11
	endselectcase

	return(0)
end

;Conversão de XML em struct
operation listarTiposVeiculo
	params;Definição de parâmetros
		       $t_cd_operador$    : IN
		string p_ls_input         : IN
		struct p_stc_output       : OUT
		       $t_ds_erro$        : OUT
	endparams
	variables ;Definição de variáveis
		struct  v_stc_requisicao, v_stc_resposta, v_stc_erro
		string  v_json_input, v_xml_output, v_json_erro
	endvariables

	;Atribui dado de xml a variável
	v_json_output = $xml

	;Converte xml em struct
	xmltostruct p_stc_output, v_xml_output

	;Trata erros
	if ($status < 0)
		if ($status != <G_ERROEXEC>)
			call PL_ERRO_CMDMSG ($procerrorcontext)
		endif

		;Retorna erro da Operation
		return (<G_ERROEXEC>)
	endif	

	;Retorna execução bem sucedida da operation
	return (0)
end

;Conversão de JSON em struct
operation listarTiposVeiculo
	params;Definição de parâmetros
		       $t_cd_operador$    : IN
		string p_ls_input         : IN
		struct p_stc_output       : OUT
		       $t_ds_erro$        : OUT
	endparams
	variables ;Definição de variáveis
		struct  v_stc_requisicao, v_stc_resposta, v_stc_erro
		string  v_json_input, v_xml_output, v_json_erro
	endvariables

	;Atribui dado de xml a variável
	v_json_output = $xml

	;Converte xml em struct
	jsontostruct p_stc_output, v_json_output

	;Trata erros
	if ($status < 0)
		if ($status != <G_ERROEXEC>)
			call PL_ERRO_CMDMSG ($procerrorcontext)
		endif

		;Retorna erro da Operation
		return (<G_ERROEXEC>)
	endif	

	;Retorna execução bem sucedida da operation
	return (0)
end

;Struct sendo processada com um laço de repetição
Entry plProcessarReservaAlimentos
	params ;Parâmetros de entrada e saída 
	;Tipo parâmetro - NomeParâmetro - Definição de entrada ou saída
		string p_ls_input		: IN
		string p_ls_output	: OUT
		       $t_ds_erro$  : OUT
	endparams	
	Variables
		Date v_dt_processo
		String v_ls_resordcarr, v_occ_resordcarr
		Handle v_instancia_CFREO047
		Struct v_stc_input, v_stc_output, v_stc_ofertas, v_stc_ofertaspend, v_stc_oferta
		Numeric v_nr_pos
		Time v_hr_expiracao, v_hr_processamento
	EndVariables

	;Inicializa vairiáveis da função
	v_dt_processo = $date
	v_hr_expiracao   = $item("hr_expiracao", p_ls_input)
	v_hr_processamento = $clock

	;Cria nova instância para chamda de operation em outro componente
	newinstance "CFREO047", v_instancia_CFREO047, "Transaction=TRUE"

	;Inicializa variáveis 
	$t_tp_operador$   = 1
	$t_cd_operador$   = 1
	v_stc_ofertas     = $newstruct
	v_stc_ofertaspend = $newstruct

	;Realiza consulta ao banco de dados
	clear/e "ctra_resordcarr"
	dt_embarque.ctra_resordcarr = "%%v_dt_processo"
	st_reserva.ctra_resordcarr  = "2" ; Reservado
	tp_segcarga.ctra_resordcarr = "1" ;alimentos
	retrieve/e "ctra_resordcarr"

	;Tratamento de erros da consulta
	if ($status < 0 & $status != -2)
		deleteinstance v_instancia_CFREO047
		$t_ds_erro$ = "Falha ao ler dados da entidade CTRA_RESORDCARR com status %%$status"
		return (<G_ERROEXEC>)
	endif

	;Tratamento de erros para retorno vazio da consulta
	if ($status = -2)
		deleteinstance v_instancia_CFREO047
		clear/e "ctra_resordcarr"	
		return (0)
	endif

	Posiciona registro na primeira ocorrencia encontrata da entidade consultada
	setocc "ctra_resordcarr", -1
	sort "ctra_resordcarr", "dt_trscria.ctra_resordcarr" ; Ordena registros pela data de criação, em ordme crescente

	;For em entidade consultada para processar registro a registro
	forentity "ctra_resordcarr"

		;Atribui dados da entidade a uma lista
		v_occ_resordcarr = ""
		putitem/id v_occ_resordcarr, "id_motorista", id_motorista.ctra_resordcarr
		putitem/id v_occ_resordcarr, "nr_versaoveic", nr_versaoveic.ctra_resordcarr
		putitem/id v_occ_resordcarr, "nr_ofertafrt", nr_ofertafrt.ctra_resordcarr
		putitem/id v_occ_resordcarr, "cd_transp", cd_transp.ctra_resordcarr
		putitem v_ls_resordcarr, -1, v_occ_resordcarr

	endfor

	;Limpa entidade consultada
	clear/e "ctra_resordcarr"

	;For em lista criada com os dados dos registros consultados
	forlist v_occ_resordcarr in v_ls_resordcarr

		;Atribui dados a uma struct
		v_stc_input                = $newstruct
		v_stc_input->id_motorista  = $item("id_motorista", v_occ_resordcarr)
		v_stc_input->nr_versaoveic = $item("nr_versaoveic", v_occ_resordcarr)
		v_stc_input->nr_ofertafrt  = $item("nr_ofertafrt", v_occ_resordcarr)
		v_stc_input->tp_operador   = $t_tp_operador$
		v_stc_input->cd_operador   = $t_cd_operador$
		v_stc_input->in_commit     = <G_TRUE>

		;Realiza chamada a uma operation em outro componente chamando pela nova instancia criada acima
		v_instancia_CFREO047->atualizarOferta(v_stc_input, v_stc_output, $t_ds_erro$)
		if ($status < 0) ;Tratamento de erros
			if ($status != <G_ERROEXEC>)
				call PL_ERRO_CMDMSG ($procerrorcontext)
			endif			
		else ;Caso não tenha erro nenhum processa os dados
			if (v_stc_output->oferta->st_oferta = 6) ; Confirmada
				v_stc_oferta            = v_stc_output->oferta
				v_stc_oferta->cd_transp = $item("cd_transp", v_occ_resordcarr)
				v_stc_ofertas->*{-1}    = v_stc_oferta
			elseif (v_stc_output->oferta->st_oferta = 1) ; Pendente
				v_stc_oferta             = v_stc_output->oferta
				v_stc_oferta->cd_transp  = $item("cd_transp", v_occ_resordcarr)
				v_stc_ofertaspend->*{-1} = v_stc_oferta
			endif
		endif
	endfor

	;Percorre registros atualizados na struct criada, utilizando um while 
	v_nr_pos     = 1
	v_stc_oferta = v_stc_ofertas->*{v_nr_pos}
	while (v_stc_oferta->$membercount > 0)

		;Chama local proc para processar registro da struct
		call PL_PROCESSAR_ITEMRES_ALIMENTOS(v_stc_oferta, v_dt_processo, v_hr_expiracao, v_hr_processamento)
		;#include LIB_COAMO:G_VLD_ACTIVATE ; Validação de erro com biblioteca 
		if ($status < 0)
			if ($status != <G_erroexec>)
				call pl_erro_cmdmsg($procerrorcontext)
			endif			
			deleteinstance v_instancia_CFREO047
			return(<G_erroexec>)
		endif
		v_nr_pos     = v_nr_pos + 1
		v_stc_oferta = v_stc_ofertas->*{v_nr_pos}
	endwhile	

	;Deleta instância criada anteriormente
	deleteinstance v_instancia_CFREO047
	 
	return (0) ; Retorna com sucesso
end

;Struct com laço de repetição e condicionais
entry plCalculaDistanciaOferta
	params ;Parâmetros de entrada e saída 
		;Tipo parâmetro - NomeParâmetro - Definição de entrada ou saída
		struct p_stc_input     : IN
		struct p_stc_output    : OUT
	endparams
	variables
		numeric v_nr_pos, v_nr_latitude, v_nr_longitude, v_nr_latorigem, v_nr_lngorigem, v_qt_distancia
		struct  v_stc_oferta
	endvariables

	;Obtem valores de variáveis da struct
	v_nr_latorigem = p_stc_input->nr_latitude
	v_nr_lngorigem = p_stc_input->nr_longitude

	; Inicializa a resposta
	p_stc_output                   = $newstruct
	p_stc_output->$tags->jsonClass = "array" ;Define tipagem do nó para criação da struct

	;Posiciona primeiro registro da struct
	v_nr_pos     = 1
	v_stc_oferta = p_stc_input->ofertas->*{v_nr_pos}
	
	;Percorre membros do primeiro registro da struct
	while (v_stc_oferta->$membercount > 0)
 
		;Obtem dados da struct
		v_nr_latitude  = v_stc_oferta->motorista->localizacao->nr_latitude
		v_nr_longitude = v_stc_oferta->motorista->localizacao->nr_longitude		

		;Atribui dados a outro nó na struct
		v_stc_oferta->nr_latorigem = v_nr_latorigem
		v_stc_oferta->nr_lngorigem = v_nr_lngorigem
		v_stc_oferta->nr_latdestino = v_nr_latitude
		v_stc_oferta->nr_longitude  = v_nr_longitude

		;Verifica condicional de preenchimento das variáveis
		if (v_nr_latorigem & v_nr_lngorigem & v_nr_latitude & v_nr_longitude)
			
			;Chama operation em outro componente
			activate "CTRAO159".CALCULA_DISTANCIA (v_nr_latorigem, v_nr_lngorigem, v_nr_latitude, v_nr_longitude, v_qt_distancia, $t_ds_erro$)

			if ($status < 0);Validação de erros
				if ($status != <G_ERROEXEC>)
					call PL_ERRO_CMDMSG ($procerrorcontext)
				endif

				return (<G_ERROEXEC>)
			endif
		
			;Verificação de resultado obtido
			if (v_qt_distancia > 0)
				; Converte a distância de m para km
				v_stc_oferta->qt_distancia = v_qt_distancia / 1000
			endif
		endif
		
		;Atribui dado do retorno a struct
		p_stc_output->*{-1} = v_stc_oferta
	
		;Vai para o próximo registro
		v_nr_pos     = v_nr_pos + 1				
		v_stc_oferta = p_stc_input->ofertas->*{v_nr_pos}
	endwhile

	return (0) ;Retorno com sucesso
end

;Conversão de struct em json
entry plReservaMotivosRecusa
	params ;Parâmetros de entrada e saída 
		;Tipo parâmetro - NomeParâmetro - Definição de entrada ou saída
		struct pStcInput   : IN
		struct pStcOutput  : OUT
		struct pStcErro    : OUT
		$t_ds_erro$        : OUT
	endparams
	variables
		struct vStcTemp, vStcToken
		string vStrUrlTemp, vStrHeader, vStrContextoErro, vStrResult, vStrJsonInput
	endvariables

	;Inicialização de estrutura para tratamento de erros
	vStrContextoErro	= "(%%$componentname%%%.plReservaMotivosRecusa)"
	vStcTemp			= ""
	$t_ds_erro$			= ""

	;Preparação de variáveis da execução
	vStcTemp->requestMethod	= "GET"

	call plUrlAmbiente(vStrUrlTemp)
	vStcTemp->url = $concat(vStrUrlTemp, "/reserva/motivos-recusa")

	vStcTemp->timeout = 60

	vStcTemp->headerDelimitator	= "@"
	vStrHeader = $concat("Content-Type: ", "application/json")

	activate "LFREO007".opAuth(vStcToken)
	if ($status < 0) ;Uso de condicional para tratamento do erro da chamada executada acima
		if ($status != <g_erroexec>)
			call pl_erro_cmdmsg($procerrorcontext)
		else
			$t_ds_erro$ = "%%$t_ds_erro$%%% %%vStrContextoErro%%%"
		endIf
		return(<g_erroexec>)
	endIf
	
	vStrHeader = $concat(vStrHeader, "@", "Authorization: ", "Bearer ", vStcToken->access_token)

	vStcTemp->header = vStrHeader

	;Converte struct em Json
	structToJson vStrJsonInput, pStcInput

	vStcTemp->payload = vStrJsonInput

	vStcTemp->componentUniface 	= $componentname

	;Chamada de API externa
	activate "WSGEW003".consomeRest(	vStcTemp->requestMethod,		    %\
										vStcTemp->url,						%\
										vStcTemp->headerDelimitator,	    %\
										vStcTemp->header,					%\
										vStcTemp->timeout,				    %\
										"true",								%\
										vStcTemp->componentUniface,	        %\
										"",									%\
										vStcTemp->payload	,				%\
										vStcTemp->inicio,					%\
										vStcTemp->fim,						%\
										vStcTemp->responseCode,		        %\
										vStcTemp->headerResponse,		    %\
										vStcTemp->restResponse               )
	if ($status < 0) ;Uso de condicional para tratamento do erro da chamada executada acima
		if ($status != <g_erroexec>)
			call pl_erro_cmdmsg($procerrorcontext)
		else
			$t_ds_erro$ = "%%$t_ds_erro$%%% %%vStrContextoErro%%%"
		endIf
		return(<g_erroexec>)
	endIf

	if ($number(vStcTemp->responseCode) >= 300)  ;Uso de condicional para tratamento do retorno de requisição
		pStcErro = ""
		call plTrataErroRequest(vStrContextoErro,vStcTemp->restResponse,pStcErro)

		$t_ds_erro$	= pStcErro->mensagem
		$t_ds_erro$	= "%%$t_ds_erro$%%% %%vStrContextoErro%%%"
		return(<g_erroexec>)
	endIf

	;Conversão dos dados
	vStrResult	= vStcTemp->restResponse
	jsonToStruct pStcOutput, vStrResult

end

;For em estrututa da struct
operation liberarViagem
	Params;Parâmetros de entrada e saída 
		;Tipo parâmetro - NomeParâmetro - Definição de entrada ou saída
		$t_tp_operador$    : in
		$t_cd_operador$    : in
		Struct p_stc_in    : in  
		$t_ds_erro$        : out
	EndParams
	variables
		numeric x, y, v_tp_creditoped, v_cd_modulo, v_cd_unidade, v_nr_procfat, v_id_veiculo, v_nr_solictransp
		numeric v_nr_tentativas, v_id_viagemped
		boolean v_in_libsemcompra
		string v_ls_param, v_ls_doctocarga, v_nm_componente, v_ls_occ
		struct v_stc_item, v_stc_param, v_stc_origemped
	endvariables

	;Try catch para tratamento de falhas
	try

		;Atribuição de valores a variáveis
		v_nm_componente       = pl_extrair_dados_struct("nm_componente", p_stc_in)
		v_tp_creditoped       = pl_extrair_dados_struct("tp_creditoped", p_stc_in)
		v_in_libsemcompra     = pl_extrair_dados_struct("in_libsemcompra", p_stc_in)

		;Validação de dados obrigatórios
		if (v_nm_componente   = "") throw -99999, "Nome do componente é um parâmetro obrigatório."
		if (v_tp_creditoped   = "") throw -99999, "Tipo de crédito do vale pedágio é um parâmetro obrigatório."
		if (v_in_libsemcompra = "") throw -99999, "Indicador de liberação da viagem sem a compra do vale pedágio é um parâmetro obrigatório."
		if ($t_tp_operador$   = "") throw -99999, "Tipo do operador é um parâmetro obrigatório"
		if ($t_tp_operador$   = "") throw -99999, "Código do operador é um parâmetro obrigatório"

		;Chamada de local proc para validação de estrutura
		if (!pl_validar_struct(p_stc_in, "nf")) ;Considicional para validação de erro
			throw -99999, "Estrutura de dados das notas fiscais não encontrada."
		else ;Caso não tenha erro

			;Processamento de laço em itens da struct
			for x = 1 to p_stc_in->nf->$collsize

				;Atribuição de dados a variáveis
				v_cd_modulo  	 	 = pl_extrair_dados_struct("cd_modulo", 	 p_stc_in->nf{x})
				v_cd_unidade	 	 = pl_extrair_dados_struct("cd_unidade", 	 p_stc_in->nf{x})
				v_nr_procfat 	 	 = pl_extrair_dados_struct("nr_procfat", 	 p_stc_in->nf{x})
				v_id_veiculo 	 	 = pl_extrair_dados_struct("id_veiculo", 	 p_stc_in->nf{x})
				v_nr_solictransp 	 = pl_extrair_dados_struct("nr_solictransp", p_stc_in->nf{x})

				;Validação de dados obrigatórios
				if (v_cd_modulo   	 = "") throw -99999, "Código do módulo é um parâmetro obrigatório."
				if (v_cd_unidade   	 = "") throw -99999, "Código da unidade é um parâmetro obrigatório."
				if (v_nr_procfat 	 = "") throw -99999, "Número do processo de faturamento é um parâmetro obrigatório."
				if (v_id_veiculo   	 = "") throw -99999, "Identificador do veículo é um parâmetro obrigatório."
				if (v_nr_solictransp = "") throw -99999, "Número da solicitação de transporte é um parâmetro obrigatório."

				;Condicional para validação de dados recuperados
				if (v_cd_modulo > 0 & v_cd_unidade > 0 & v_nr_procfat > 0 & v_nr_solictransp > 0)
				
					;Validação e consulta de dados
					v_nr_tentativas = 0
					repeat
						sleep 2000
						v_ls_param = ""
						putitem/id v_ls_param, "cd_modfat",  	 v_cd_modulo
						putitem/id v_ls_param, "cd_unidfat", 	 v_cd_unidade
						putitem/id v_ls_param, "nr_procfat", 	 v_nr_procfat
						putitem/id v_ls_param, "nr_solictransp", v_nr_solictransp
						activate "ctrao201".obtem_occ_retr("ctra_doctocarga", v_ls_param, v_ls_doctocarga, $t_ds_erro$)
						#include LIB_COAMO:G_THROW_T_DS_ERRO
						v_nr_tentativas += 1 
					until (v_ls_doctocarga != "" | v_nr_tentativas = 10)

					;Validação de retorno de dados da consulta
					if (v_ls_doctocarga = "")
						throw -99999, "Não foi encontrado o vínculo da nota fiscal com a carga da viagem do vale pedágio. (CTRA_DOCTOCARGA)."
					endif
	
					;For em lista retornada
					forlist v_ls_occ in v_ls_doctocarga
						v_stc_param = $newstruct
						v_stc_item  = $newstruct
						v_stc_item->nr_solictransp 	  = v_nr_solictransp
						v_stc_item->nr_carga       	  = pl_extrair_dados_lista("nr_carga", v_ls_occ)
						v_stc_param->programacao{-1}  = v_stc_item

						;Chamada de operation em outro componente para aplicação de regra
						activate "ctrao322".opObterOrigemViagem(v_stc_param, v_stc_origemped, $t_ds_erro$)
						#include LIB_COAMO:G_THROW_T_DS_ERRO ;VAlidação de erro com biblioteca

						;Validação de estrutura da struct com Local Proc
						if (!pl_validar_struct(v_stc_origemped, "OCC"))
							throw -99999, "Registro da origem da viagem do vale pedágio não encontrado.(CTRA_ORIGEMPED)."
						else ;Caso sem erro

						    ;For em estrututa da struct
							for y = 1 to v_stc_origemped->OCC->$collsize

								;Atribuição de dados a variáveis
								v_id_viagemped = pl_extrair_dados_struct("ID_VIAGEMPED", v_stc_origemped->OCC{y})
								v_stc_param = $newstruct
								v_stc_param->nm_componente   = v_nm_componente
								v_stc_param->in_libsemcompra = v_in_libsemcompra

								;Chamada de Local Proc para aplicação de regra
								call plLiberarViagem("", "", v_id_viagemped, v_tp_creditoped, v_stc_param)
							endfor
						endif
					endfor
				endif
			endfor
		endif
	catch
		;Lançamento de exceção
		call PL_EXCECAO_MSG($procerrorcontext)
		return (<G_ERROEXEC>) ;Retorno com erro
	endtry
	
	return (0) ;Retorno com sucesso
end